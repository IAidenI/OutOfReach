#include "functions.h"

int GetValue(int memoryFile, off_t address, float *getValue) {
    // Se place au niveau de la speed
    if (lseek(memoryFile, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        return 1;
    }

    // Lit la valeur
    if (read(memoryFile, getValue, sizeof(*getValue)) != sizeof(*getValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        return 1;
    }
    return 0;
}

int SetValue(int memoryFile, off_t address, float newValue) {
    // Se place au niveau de la speed
    if (lseek(memoryFile, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        return 1;
    }

    // Lit la valeur
    if (write(memoryFile, &newValue, sizeof(newValue)) != sizeof(newValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        return 1;
    }

    return 0;
}

int isCloseFloat(float a, float b, float eps) {
    return fabsf(a - b) < eps; // Supprime les signe et vérifie si la différence est dans la marge d'erreur eps
}

int ScanSegment(int fp, unsigned long addrStart, unsigned long addrEnd, uintptr_t *playerAddr) {
    unsigned long sectionSize = addrEnd - addrStart;
    if (sectionSize < sizeof(Player)) return 1;

    unsigned char *buffer = malloc(CHUNK_SIZE);
    if (!buffer) {
        fprintf(stderr, "[-] Impossible d'allouer de la mémoire pour le scan.\n");
        return 1;
    }

    unsigned long offset = 0;

    while (offset < sectionSize) {
        // Détermine la taille a lire dans ce chunk
        unsigned long toRead = CHUNK_SIZE;
        if (offset + toRead > sectionSize) {
            toRead = sectionSize - offset;
        }

        // Se place au bon endroit dans la mémoire
        if (lseek(fp, (off_t)(addrStart + offset), SEEK_SET) == (off_t)-1) {
            perror("lseek");
            fprintf(stderr, "[-] Impossible de trouver l'offset : 0x%lx.\n", offset);
            free(buffer);
            return 1;
        }

        // Lit le chunk
        ssize_t n = read(fp, buffer, toRead);
        if (n <= 0) break;

        // Test chaques position possible comme un Player
        for (ssize_t i = 0; i <= n - (ssize_t)sizeof(Player); i++ ) {
            Player* p = (Player *)(buffer + i);

            float expect_px = 0.0f;
            float expect_py = 2.0f;
            float expect_pz = 0.0f;
            float expect_sp = 5.0f;
            float expect_h  = 5.0f;
            float eps = 0.0001f;

            // Utilisation de isCloseFloat car en ram 10.0 sera pas forcément 10.0, ça sera
            // Peut être 10.0000019073 ou 9.9999990463 donc if (p->position.x == 10.0f) échouera
            // Donc si la différence entre 2 float est < eps (marge d'erreur) alors on considère qu'il sont égaux
            if (isCloseFloat(p->position.x, expect_px, eps) && 
                isCloseFloat(p->position.y, expect_py, eps) &&
                isCloseFloat(p->position.z, expect_pz, eps) &&
                isCloseFloat(p->speed, expect_sp, eps) &&
                isCloseFloat(p->height, expect_h, eps)) {
                // Le joueur a été trouvé
                *playerAddr = (uintptr_t)(addrStart + offset + i);
                free(buffer);
                return 0;
            }
        }

        // Avance l'offset
        if (toRead > sizeof(Player)) offset += (toRead - sizeof(Player));
        else offset += toRead;
    }

    free(buffer);
    return 1;
}

int FindPlayer(int pid, uintptr_t *playerAddr) {
    char mapsPath[PATH_SIZE];
    snprintf(mapsPath, sizeof(mapsPath), "/proc/%d/maps", pid);
    FILE *maps = fopen(mapsPath, "r");

    if (!maps) {
        perror("fopen");
        fprintf(stderr, "[-] Impossible d'accèder au fichier : %s.\n", mapsPath);
        return 1;
    }

    char memoryPath[PATH_SIZE];
    snprintf(memoryPath, sizeof(memoryPath), "/proc/%d/mem", pid);
    int memory = open(memoryPath, O_RDONLY);

    if (memory == -1) {
        perror("fopen");
        fprintf(stderr, "[-] Impossible d'accèder au fichier : %s.\n", mapsPath);
        fclose(maps);
        return 1;
    }

    char line[512];
    while (fgets(line, sizeof(line), maps)) {
        unsigned long start, end;
        char perms[5] = { 0 };
        
        int n = sscanf(line, "%lx-%lx %4s %*s %*s %*s %*s", &start, &end, perms);

        if (n < 3) continue;
        if (perms[0] != 'r' || perms[1] != 'w') continue;

        // On scan le segment
        if (ScanSegment(memory, start, end, playerAddr) == 0) {
            fclose(maps);
            close(memory);
            return 0;
        }
    }
    fclose(maps);
    close(memory);
    return 1;
}

int Teleport(int memoryFile, Position3D newPosition, RuntimeAddr address) {
    // Récupère les anciennes valeurs
    Position3D oldPosition = { 0.0f };
    float oldValue = 0;
    if (GetValue(memoryFile, (off_t)address.positionX, &oldValue)) return 1;
    oldPosition.x += oldValue;

    if (GetValue(memoryFile, (off_t)address.positionY, &oldValue)) return 1;
    oldPosition.y += oldValue;

    if (GetValue(memoryFile, (off_t)address.positionZ, &oldValue)) return 1;
    oldPosition.z += oldValue;
    printf("[+] Acienne position du joueur : X=%.2f;Y=%.2f;Z=%.2f\n", oldPosition.x, oldPosition.y, oldPosition.z);

    // Mets les nouvelles valeurs a jour
    if (SetValue(memoryFile, (off_t)address.positionX, newPosition.x)) return 1;
    if (SetValue(memoryFile, (off_t)address.positionY, newPosition.y)) return 1;
    if (SetValue(memoryFile, (off_t)address.positionZ, newPosition.z)) return 1;

    // Vérification
    Position3D verificationPosition = { 0.0f };
    if (GetValue(memoryFile, (off_t)address.positionX, &oldValue)) return 1;
    verificationPosition.x += oldValue;

    if (GetValue(memoryFile, (off_t)address.positionY, &oldValue)) return 1;
    verificationPosition.y += oldValue;

    if (GetValue(memoryFile, (off_t)address.positionZ, &oldValue)) return 1;
    verificationPosition.z += oldValue;

    printf("[+] Joueur téléporté en X=%.2f;Y=%.2f;Z=%.2f\n", verificationPosition.x, verificationPosition.y, verificationPosition.z);
    return 0;
}
