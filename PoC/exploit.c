#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ptrace.h>
#include <string.h>
#include <sys/wait.h>
#include <stdint.h>
#include <stddef.h>
#include <math.h>


#define PATH_SIZE  64
#define CHUNK_SIZE 0x4000


typedef struct {
    float x;
    float y;
} Position;

typedef struct {
    float width;
    float height;
} Size;

typedef struct {
    const char *name;
    Position position;
    Size size;
    float speed;
} Player;

int GetValue(int memoryFile, off_t address, float *getValue);
int SetValue(int memoryFile, off_t address, float newValue);
int isCloseFloat(float a, float b, float eps);
int ScanSegment(int fp, unsigned long addrStart, unsigned long addrEnd, uintptr_t *playerAddr);
int FindPlayer(int pid, uintptr_t *playerAddr);

int GetValue(int memoryFile, off_t address, float *getValue) {
    // Se place au niveau de la speed
    if (lseek(memoryFile, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        return 1;
    }

    // Lit la valeur
    if (read(memoryFile, getValue, sizeof(*getValue)) != sizeof(*getValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        return 1;
    }
    return 0;
}

int SetValue(int memoryFile, off_t address, float newValue) {
    // Se place au niveau de la speed
    if (lseek(memoryFile, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        return 1;
    }

    // Lit la valeur
    if (write(memoryFile, &newValue, sizeof(newValue)) != sizeof(newValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        return 1;
    }

    return 0;
}

int isCloseFloat(float a, float b, float eps) {
    return fabsf(a - b) < eps; // Supprime les signe et vérifie si la différence est dans la marge d'erreur eps
}

int ScanSegment(int fp, unsigned long addrStart, unsigned long addrEnd, uintptr_t *playerAddr) {
    unsigned long sectionSize = addrEnd - addrStart;
    if (sectionSize < sizeof(Player)) return 1;

    unsigned char *buffer = malloc(CHUNK_SIZE);
    if (!buffer) {
        fprintf(stderr, "[-] Impossible d'allouer de la mémoire pour le scan.\n");
        return 1;
    }

    unsigned long offset = 0;

    while (offset < sectionSize) {
        // Détermine la taille a lire dans ce chunk
        unsigned long toRead = CHUNK_SIZE;
        if (offset + toRead > sectionSize) {
            toRead = sectionSize - offset;
        }

        // Se place au bon endroit dans la mémoire
        if (lseek(fp, (off_t)(addrStart + offset), SEEK_SET) == (off_t)-1) {
            perror("lseek");
            fprintf(stderr, "[-] Impossible de trouver l'offset : 0x%lx.\n", offset);
            free(buffer);
            return 1;
        }

        // Lit le chunk
        ssize_t n = read(fp, buffer, toRead);
        if (n <= 0) break;

        // Test chaques position possible comme un Player
        for (ssize_t i = 0; i <= n - (ssize_t)sizeof(Player); i++ ) {
            Player* p = (Player *)(buffer + i);

            float expect_px = 10.0f;
            float expect_py = 15.0f;
            float expect_w  = 50.0f;
            float expect_h  = 80.0f;
            float expect_sp = 5.0f;
            float eps = 0.0001f;

            // Utilisation de isCloseFloat car en ram 10.0 sera pas forcément 10.0, ça sera
            // Peut être 10.0000019073 ou 9.9999990463 donc if (p->position.x == 10.0f) échouera
            // Donc si la différence entre 2 float est < eps (marge d'erreur) alors on considère qu'il sont égaux
            if (isCloseFloat(p->position.x, expect_px, eps) && 
                isCloseFloat(p->position.y, expect_py, eps) &&
                isCloseFloat(p->size.width, expect_w, eps) &&
                isCloseFloat(p->size.height, expect_h, eps) &&
                isCloseFloat(p->speed, expect_sp, eps)) {
                // Le joueur a été trouvé
                *playerAddr = (uintptr_t)(addrStart + offset + i);
                free(buffer);
                return 0;
            }
        }

        // Avance l'offset
        if (toRead > sizeof(Player)) offset += (toRead - sizeof(Player));
        else offset += toRead;
    }

    free(buffer);
    return 1;
}

int FindPlayer(int pid, uintptr_t *playerAddr) {
    char mapsPath[PATH_SIZE];
    snprintf(mapsPath, sizeof(mapsPath), "/proc/%d/maps", pid);
    FILE *maps = fopen(mapsPath, "r");

    if (!maps) {
        perror("fopen");
        fprintf(stderr, "[-] Impossible d'accèder au fichier : %s.\n", mapsPath);
        return 1;
    }

    char memoryPath[PATH_SIZE];
    snprintf(memoryPath, sizeof(memoryPath), "/proc/%d/mem", pid);
    int memory = open(memoryPath, O_RDONLY);

    if (memory == -1) {
        perror("fopen");
        fprintf(stderr, "[-] Impossible d'accèder au fichier : %s.\n", mapsPath);
        fclose(maps);
        return 1;
    }

    char line[512];
    while (fgets(line, sizeof(line), maps)) {
        unsigned long start, end;
        char perms[5] = { 0 };
        
        int n = sscanf(line, "%lx-%lx %4s %*s %*s %*s %*s", &start, &end, perms);

        if (n < 3) continue;
        if (perms[0] != 'r' || perms[1] != 'w') continue;

        // On scan le segment
        if (ScanSegment(memory, start, end, playerAddr) == 0) {
            fclose(maps);
            close(memory);
            return 0;
        }
    }
    fclose(maps);
    close(memory);
    return 1;
}


int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage : %s <pid>\n", argv[0]);
        return 1;
    }

    // S'attache au processus cible
    int pid = atoi(argv[1]);
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL)) {
        perror("ptrace(PTRACE_ATTACH)");
        fprintf(stderr, "[-] Impossible de s'attacher au processus.\n");
        return 1;
    }

    // Attend la pause du processus
    if (waitpid(pid, NULL, 0) == -1) {
        perror("wait");
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        fprintf(stderr, "[-] Impossible d'attendre le processus.\n");
        return 1;
    }

    // Recherche du joueur
    uintptr_t playerAddr = 0;
    if (FindPlayer(pid, &playerAddr)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        fprintf(stderr, "[-] Impossible de trouver le joueur.\n");
        return 1;
    }

    printf("[+] Joueur trouvé à 0x%lx\n", (unsigned long)playerAddr);

    // Récupère l'adresse de la position
    size_t posXOffset = offsetof(Player, position) + offsetof(Position, x);
    size_t posYOffset = offsetof(Player, position) + offsetof(Position, y);

    off_t posXAddr = (off_t)(playerAddr + posXOffset);
    off_t posYAddr = (off_t)(playerAddr + posYOffset);

    // Lit la RAM du processus
    char memoryPath[PATH_SIZE];
    snprintf(memoryPath, sizeof(memoryPath), "/proc/%d/mem", pid);
    int memory = open(memoryPath, O_RDWR);

    if (memory == -1) {
        perror("open");
        fprintf(stderr, "[-] Impossible d'accèder au fichier %s\n", memoryPath);
        return 1;
    }

    // Récupère l'acnienne valeur
    float posXOldValue = 0.0f;
    if (GetValue(memory, posXAddr, &posXOldValue)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        close(memory);
        return 1;
    }

    float posYOldValue = 0.0f;
    if (GetValue(memory, posYAddr, &posYOldValue)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        close(memory);
        return 1;
    }

    printf("[+] Position du joueur : X=%.2f;Y=%.2f\n", posXOldValue, posYOldValue);

    printf("[ ] Modification en cours...\n");
    float posXNewValue = 100.0f;
    float posYNewValue = 50.0f;

    if (SetValue(memory, posXAddr, posXNewValue)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        close(memory);
        return 1;
    }

    if (SetValue(memory, posYAddr, posYNewValue)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        close(memory);
        return 1;
    }

    printf("[+] Position du joueur modifié par : X=%.2f;Y=%.2f\n", posXNewValue, posYNewValue);

    close(memory);
    ptrace(PTRACE_DETACH, pid, NULL, NULL);
    return 0;
}
