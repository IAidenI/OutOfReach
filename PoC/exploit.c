#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ptrace.h>
#include <string.h>
#include <sys/wait.h>
#include <stdint.h>
#include <stddef.h>

#define PATH_SIZE 65

typedef struct {
    float x;
    float y;
} Position;

typedef struct {
    float width;
    float height;
} Size;

typedef struct {
    const char *name;
    Position position;
    Size size;
    float speed;
} Player;

int GetSpeedValue(int pid, off_t address, float *getValue);
int SetSpeedValue(int pid, off_t address, float newValue);
int GetELFBase(int pid, uintptr_t *elfBase);
unsigned long GetPlayerOffset(int pid);

unsigned long GetPlayerOffset(int pid) {
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "nm /proc/%d/exe 2>/dev/null | awk '$3==\"player\"{print \"0x\"$1; exit}'", pid);

    FILE *fp = popen(cmd, "r");
    if (!fp) {
        perror("popen");
        fprintf(stderr, "[-] Impossible de récupèrer l'offset du joueur.\n");
        return -1;
    }

    char buf[64] = { 0 };
    if (!fgets(buf, sizeof(buf), fp)) {
        pclose(fp);
        return -1;
    }
    pclose(fp);
    return strtoul(buf, NULL, 16);
}

int GetSpeedValue(int pid, off_t address, float *getValue) {
    // Lit la RAM du processus
    char memoryPath[64];
    snprintf(memoryPath, sizeof(memoryPath), "/proc/%d/mem", pid);
    int memory = open(memoryPath, O_RDONLY);

    if (memory == -1) {
        perror("open");
        fprintf(stderr, "[-] Impossible d'accèder au fichier %s\n", memoryPath);
        return 1;
    }

    // Se place au niveau de la speed
    if (lseek(memory, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        close(memory);
        return 1;
    }

    // Lit la valeur
    if (read(memory, getValue, sizeof(*getValue)) != sizeof(*getValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        close(memory);
        return 1;
    }

    close(memory);
    return 0;
}

int SetSpeedValue(int pid, off_t address, float newValue) {
    // Lit la RAM du processus
    char memoryPath[PATH_SIZE];
    snprintf(memoryPath, sizeof(memoryPath), "/proc/%d/mem", pid);
    int memory = open(memoryPath, O_RDWR);

    if (memory == -1) {
        perror("open");
        fprintf(stderr, "[-] Impossible d'accèder au fichier %s\n", memoryPath);
        return 1;
    }

    // Se place au niveau de la speed
    if (lseek(memory, address, SEEK_SET) == (off_t)-1) {
        perror("lseek");
        fprintf(stderr, "[-] Impossible de trouver l'offset.\n");
        close(memory);
        return 1;
    }

    // Lit la valeur
    if (write(memory, &newValue, sizeof(newValue)) != sizeof(newValue)) {
        perror("read");
        fprintf(stderr, "[-] Impossible de trouver la donnée.\n");
        close(memory);
        return 1;
    }

    close(memory);
    return 0;
}

int GetELFBase(int pid, uintptr_t *elfBase) {
    // Lit le chemin d'accès du fichier exécuté
    char exeLink[64];
    snprintf(exeLink, sizeof(exeLink), "/proc/%d/exe", pid);

    char exeRealPath[256];
    ssize_t len = readlink(exeLink, exeRealPath, sizeof(exeRealPath) - 1);
    if (len == -1) {
        perror("readlink");
        return 1;
    }
    exeRealPath[len] = '\0';

    // Récupère l'adresse de base
    char mapsPath[PATH_SIZE];
    snprintf(mapsPath, sizeof(mapsPath), "/proc/%d/maps", pid);
    
    FILE *maps = fopen(mapsPath, "r");
    if (maps == NULL) {
        perror("open");
        fprintf(stderr, "[-] Impossible d'accèder au fichier %s\n", mapsPath);
        return 1;
    }

    char line[512];
    while (fgets(line, sizeof(line), maps)) {
        unsigned long start, end;
        char perms[5] = { 0 };
        unsigned long offset;
        char path[256] = { 0 };
        
        int n = sscanf(line, "%lx-%lx %4s %lx %*s %*s %255s", &start, &end, perms, &offset, path);

        if (n == 5) {
            if (strstr(line, exeRealPath) != NULL && offset == 0) {
                *elfBase = start;
                break;
            }
        }
    }
    fclose(maps);
    return 0;
}



int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage : %s <pid>\n", argv[0]);
        return 1;
    }

    // S'attache au processus cible
    int pid = atoi(argv[1]);
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL)) {
        perror("ptrace(PTRACE_ATTACH)");
        fprintf(stderr, "[-] Impossible de s'attacher au processus.\n");
        return 1;
    }

    waitpid(pid, NULL, 0); // Attend la pause du processus

    // Récupère l'adresse de base du binaire
    uintptr_t elfBase = 0;
    if (GetELFBase(pid, &elfBase)) {
        ptrace(PT_DETACH, pid, NULL, NULL);
        return 1;
    }

    if (elfBase == 0) {
        printf("[-] ELF base introuvable.\n");
    } else {
        printf("[+] ELF base : 0x%lx.\n", (unsigned long)elfBase);
    }

    // Ajoute l'offset de la variable cible
    unsigned long elfPlayerOffset = GetPlayerOffset(pid);
    if (elfPlayerOffset == -1) {
        ptrace(PT_DETACH, NULL, NULL);
        return 1;
    }
    printf("[+] Addresse ELF du joueur : 0x%lx\n", elfPlayerOffset);
    size_t speedOffset = offsetof(Player, speed);
    unsigned long elfSpeedOffset = elfPlayerOffset + speedOffset;
    uintptr_t runtimeSpeedAddr = elfBase + elfSpeedOffset;
    printf("[+] Addresse de player.speed : 0x%lx\n", (unsigned long)runtimeSpeedAddr);

    // Lit l'acienne valeur de la speed du joueur
    float oldValue = 0;
    if (GetSpeedValue(pid, (off_t)runtimeSpeedAddr, &oldValue)) {
        ptrace(PT_DETACH, NULL, NULL);
        return 1;
    }

    // La modifie
    if (SetSpeedValue(pid, (off_t)runtimeSpeedAddr, 15.0f)) {
        ptrace(PT_DETACH, NULL, NULL);
        return 1;
    }

    // Lit la nouvelle valeur pour vérification
    float newValue = 0;
    if (GetSpeedValue(pid, (off_t)runtimeSpeedAddr, &newValue)) {
        ptrace(PT_DETACH, NULL, NULL);
        return 1;
    }

    printf("[+] Remplace la vitesse de %.2f par %.2f\n", oldValue, newValue);

    ptrace(PT_DETACH, pid, NULL, NULL);
    return 0;
}
